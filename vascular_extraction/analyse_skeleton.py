#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Created on Mon Aug 26 20:07:49 2024

@author: Vedang Narain (vedang.narain@msdtc.ox.ac.uk)

This script reads the skeletonisation output generated by Fiji and generates CD31 and lectin (edges) and cell (point) matrices for use in MV Chaste.

"""

# =============================================================================
# IMPORT LIBRARIES
# =============================================================================

# Import libraries
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
from scipy.spatial import distance
from scipy.spatial import KDTree

# Set LaTex-style font
plt.rcParams['mathtext.fontset'] = 'stix'
plt.rcParams['font.family'] = 'STIXGeneral'
plt.rcParams.update({'font.size': 22})
# sns.set(font='STIXGeneral', font_scale=1.7)

# =============================================================================
# FUNCTIONS
# =============================================================================

# Define a function to filter out fragments from the dataframe
def clean_skeleton(df):

    # Count the number of edges per Skeleton ID
    skeleton_counts = df['Skeleton ID'].value_counts()
    
    # Filter out small skeletons
    valid_skeleton_ids = skeleton_counts[skeleton_counts >= minimum_size].index
    
    # Filter the dataframe to keep only edges from valid skeletons
    filtered_df = df[df['Skeleton ID'].isin(valid_skeleton_ids)]
    
    # Filter out edges where the Euclidean distance is less than 1 µm
    filtered_df = filtered_df[filtered_df['Euclidean distance'] >= 1]
    
    # Create a list of remaining unique Skeleton IDs
    skeleton_ids = filtered_df['Skeleton ID'].unique()
    
    return filtered_df, skeleton_ids

# Define a function to calculate the minimum distance between endpoints of two edges
def edge_distance(edge1, edge2):
    distances = [
        distance.euclidean((edge1['x1'], edge1['y1']), (edge2['x1'], edge2['y1'])),
        distance.euclidean((edge1['x1'], edge1['y1']), (edge2['x2'], edge2['y2'])),
        distance.euclidean((edge1['x2'], edge1['y2']), (edge2['x1'], edge2['y1'])),
        distance.euclidean((edge1['x2'], edge1['y2']), (edge2['x2'], edge2['y2'])),
    ]
    return min(distances)

# Define a function to check if the overlap discrepancy is within the permitted tolerance
def check_overlap(edge1, edge2, tolerance):
    return edge_distance(edge1, edge2) < tolerance

# Define a function to extract the midpoints of each edge to use as representatives for the KDTree
def edge_midpoint(df):
    mid_x = (df['x1'] + df['x2']) / 2
    mid_y = (df['y1'] + df['y2']) / 2
    return np.vstack((mid_x, mid_y)).T

# =============================================================================
# ENTER KEY PARAMETERS
# =============================================================================

# Load the data from the Fiji files
df_cd31 = pd.read_csv('/Users/vedang/Desktop/Zofia/Segmentation/ilastik/Branch information (CD31).csv')
df_lectin = pd.read_csv('/Users/vedang/Desktop/Zofia/Segmentation/ilastik/Branch information (lectin).csv')
df_cells = pd.read_csv('/Users/vedang/Desktop/Zofia/Segmentation/ilastik/Results_cells.csv')
# df_cd31 = pd.read_csv('/Users/vedang/Desktop/Zofia/Final Dataset/reduced_CD31.csv')

# Set the image side length (in pixels)
image_height_um = 1214.56

# In case the image and skeleton dimensions are different
'''
image_height_pixel = 2048
pixels_per_um = image_height_pixel/image_height_um
columns_to_convert = ['Branch length', 'V1 x', 'V1 y', 'V1 z', 'V2 x', 'V2 y', 'V2 z', 'Euclidean distance', 'running average length']  
for col in columns_to_convert:
    df_cd31[col] = df_cd31[col] / pixels_per_um
# pixels_per_um = 1.6862
# image_height = round(image_height_um*pixels_per_um)
'''

# Set the desired minimum number of edges in a connected component (delete fragments)
minimum_size = 30

# Load the image 
cd31_image_path = '/Users/vedang/Desktop/Zofia/Final Dataset/thesis/projections after filtering/CD31.jpg'  
cd31_background_image = plt.imread(cd31_image_path)
lectin_image_path = '/Users/vedang/Desktop/Zofia/Final Dataset/thesis/projections after filtering/lectin.jpg'  
lectin_background_image = plt.imread(lectin_image_path)
dapi_image_path = '/Users/vedang/Desktop/Zofia/Final Dataset/thesis/projections after filtering/DAPI.jpg' 
dapi_background_image = plt.imread(dapi_image_path)

# =============================================================================
# PLOT VESSELS
# =============================================================================
    
# Get CD31
filtered_df_cd31, skeleton_ids_cd31 = clean_skeleton(df_cd31)

# Create a color map for different Skeleton IDs
colors = plt.cm.viridis(np.linspace(0, 1, len(skeleton_ids_cd31)))
bright_colors = ['yellow', 'green', 'blue', 'red', 'C0']

# Create the plot with square dimensions (to match the image)
dpi = 100  # Dots per inch
fig_size = image_height_um / dpi  # Convert pixel size to inches
plt.figure(figsize=(fig_size, fig_size), dpi=dpi)

# Display the background image
plt.imshow(cd31_background_image, cmap='gray', extent=[0, image_height_um, image_height_um, 0])  # Adjust extent to fit the 1024x1024 size
# plt.imshow(lectin_background_image, cmap='gray', extent=[0, image_height_um, image_height_um, 0])  # Adjust extent to fit the 1024x1024 size

# Plot each Skeleton ID with a different color
for i, skeleton_id in enumerate(skeleton_ids_cd31):
    subset = filtered_df_cd31[filtered_df_cd31['Skeleton ID'] == skeleton_id]
    # Plot each line segment
    for _, row in subset.iterrows():
        # plt.plot([row['V1 x'], row['V2 x']], [row['V1 y'], row['V2 y']], color=colors[i])
        plt.plot([row['V1 x'], row['V2 x']], [row['V1 y'], row['V2 y']], color=bright_colors[i], lw=1)

# Ensure the origin is at the top left
plt.gca().invert_yaxis()  # Invert the y-axis to match Fiji's top-left origin

# Set equal scaling to maintain square aspect ratio
plt.gca().set_aspect('equal', adjustable='box')

# Set x and y limits to match the square dimensions of the image
plt.xlim(0, image_height_um)
plt.ylim(image_height_um, 0)  # Inverted y-axis, so 1024 is at the top

# Label the plot
plt.xlabel('x-axis (μm)')
plt.ylabel('y-axis (μm)')

# plt.title('CD31 skeleton overlay on image')
plt.grid(False)  # Optionally turn off grid for better image visibility

# Show plot
plt.show()

# Set the directory to save the edge matrices
output_dir = 'CD31EdgeMatrices'
os.makedirs(output_dir, exist_ok=True)

# Create an edge list for the combined skeleton
combined_edges = []

# Iterate over each Skeleton ID and create a separate file for each
for skeleton_id in skeleton_ids_cd31:
    subset = filtered_df_cd31[filtered_df_cd31['Skeleton ID'] == skeleton_id]
    
    # Define the filename based on the Skeleton ID
    filename = os.path.join(output_dir, f'Skeleton_{skeleton_id}.txt')
    
    # Track unique edges using a set
    unique_edges = set()

    # Open the file to write the edges matrix for this skeleton
    with open(filename, 'w') as file:
        edge_number = 1  # Initialize the edge counter
        # Write each line segment to the file with y-coordinate adjustment and edge number
        for _, row in subset.iterrows():
            y1_adjusted = image_height_um - row['V1 y']
            y2_adjusted = image_height_um - row['V2 y']

            # Create a sorted tuple to represent an edge uniquely
            edge_tuple = tuple(sorted([(row['V1 x'], y1_adjusted), (row['V2 x'], y2_adjusted)]))

            if edge_tuple not in unique_edges:
                unique_edges.add(edge_tuple)  # Add the edge to the set
                edge_line = f"{row['V1 x']}\t{y1_adjusted}\t{row['V2 x']}\t{y2_adjusted}\t{edge_number}\n"
                file.write(edge_line)
                combined_edges.append(edge_line)  # Add to combined list
                edge_number += 1

# Write the combined edge matrix to a single .txt file
combined_filename = os.path.join(output_dir, 'CombinedSkeletons.txt')
with open(combined_filename, 'w') as combined_file:
    combined_file.writelines(combined_edges)            
            
# =============================================================================
# PLOT LECTIN
# =============================================================================    

# Get lectin
filtered_df_lectin, skeleton_ids_lectin = clean_skeleton(df_lectin)

# Create a color map for different Skeleton IDs
colors = plt.cm.viridis(np.linspace(0, 1, len(skeleton_ids_lectin)))
bright_colors = ['yellow', 'green']

# Create the plot with square dimensions (to match the image)
dpi = 100  # Dots per inch
fig_size = image_height_um / dpi  # Convert pixel size to inches
plt.figure(figsize=(fig_size, fig_size), dpi=dpi)

# Display the background image
plt.imshow(lectin_background_image, cmap='gray', extent=[0, image_height_um, image_height_um, 0])  # Adjust extent to fit the 1024x1024 size

# Plot each Skeleton ID with a different color
for i, skeleton_id in enumerate(skeleton_ids_lectin):
    subset = filtered_df_lectin[filtered_df_lectin['Skeleton ID'] == skeleton_id]
    # Plot each line segment
    for _, row in subset.iterrows():
        # plt.plot([row['V1 x'], row['V2 x']], [row['V1 y'], row['V2 y']], color=colors[i])
        plt.plot([row['V1 x'], row['V2 x']], [row['V1 y'], row['V2 y']], color=bright_colors[i], lw=1)

# Ensure the origin is at the top left
plt.gca().invert_yaxis()  # Invert the y-axis to match Fiji's top-left origin

# Set equal scaling to maintain square aspect ratio
plt.gca().set_aspect('equal', adjustable='box')

# Set x and y limits to match the square dimensions of the image
plt.xlim(0, image_height_um)
plt.ylim(image_height_um, 0)  # Inverted y-axis, so 1024 is at the top

# Label the plot
plt.xlabel('x-axis (μm)')
plt.ylabel('y-axis (μm)')
# plt.title('Lectin skeleton overlay on image')
plt.grid(False)  # Optionally turn off grid for better image visibility

# Show plot
plt.show()

# Set the directory to save the edge matrices
output_dir = 'lectinEdgeMatrices'
os.makedirs(output_dir, exist_ok=True)

# Create an edge list for the combined skeleton
combined_edges = []

# Iterate over each Skeleton ID and create a separate file for each
for skeleton_id in skeleton_ids_lectin:
    subset = filtered_df_lectin[filtered_df_lectin['Skeleton ID'] == skeleton_id]
    
    # Define the filename based on the Skeleton ID
    filename = os.path.join(output_dir, f'Skeleton_{skeleton_id}.txt')
    
    # Track unique edges using a set
    unique_edges = set()

    # Open the file to write the edges matrix for this skeleton
    with open(filename, 'w') as file:
        edge_number = 1  # Initialize the edge counter
        # Write each line segment to the file with y-coordinate adjustment and edge number
        for _, row in subset.iterrows():
            y1_adjusted = image_height_um - row['V1 y']
            y2_adjusted = image_height_um - row['V2 y']

            # Create a sorted tuple to represent an edge uniquely
            edge_tuple = tuple(sorted([(row['V1 x'], y1_adjusted), (row['V2 x'], y2_adjusted)]))

            if edge_tuple not in unique_edges:
                unique_edges.add(edge_tuple)  # Add the edge to the set
                edge_line = f"{row['V1 x']}\t{y1_adjusted}\t{row['V2 x']}\t{y2_adjusted}\t{edge_number}\n"
                file.write(edge_line)
                combined_edges.append(edge_line)  # Add to combined list
                edge_number += 1

# Write the combined edge matrix to a single .txt file
combined_filename = os.path.join(output_dir, 'CombinedSkeletons.txt')
with open(combined_filename, 'w') as combined_file:
    combined_file.writelines(combined_edges)            
    
# =============================================================================
# PLOT CELLS
# =============================================================================

# Get the right arrays
cells_x = df_cells['X']
cells_y = df_cells['Y']
cells_area = df_cells['Area']

# Calculate the effective diameter for the same area
diameters = 2 * np.sqrt(cells_area / np.pi)

# Create the plot with square dimensions (to match the image)
dpi = 100  # Dots per inch
fig_size = image_height_um / dpi  # Convert pixel size to inches
plt.figure(figsize=(fig_size, fig_size), dpi=dpi)
8
# Display the background image
plt.imshow(dapi_background_image, cmap='gray', extent=[0, image_height_um, image_height_um, 0])  # Adjust extent to fit the 1024x1024 size

# Scale the diameters to make the plot visually appropriate
scaling_factor = 10
sizes = diameters * scaling_factor

# Plot cells as a scatter plot
plt.scatter(cells_x, cells_y, c='blue', marker='o', alpha=0.5, s=sizes)

# Ensure the origin is at the top left
plt.gca().invert_yaxis()  # Invert the y-axis to match Fiji's top-left origin

# Set equal scaling to maintain square aspect ratio
plt.gca().set_aspect('equal', adjustable='box')

# Set x and y limits to match the square dimensions of the image
plt.xlim(0, image_height_um)
plt.ylim(image_height_um, 0)  # Inverted y-axis, so 1024 is at the top

# Label the plot
plt.xlabel('x-axis (μm)')
plt.ylabel('y-axis (μm)')
# plt.title('Cells overlay on image')
plt.grid(False)  # Optionally turn off grid for better image visibility

# Show plot
plt.show()    

# Adjust the origin
adjusted_y = image_height_um - cells_y

# Combine the matrix and round the coordinates to 1 µm precision
df_cells_combined = pd.DataFrame({
    'x': round(cells_x),
    'y': round(adjusted_y),
    'd': diameters})

# Drop overlapping points
df_unique = df_cells_combined.drop_duplicates(subset=['x', 'y'])

# Save as a tab-separated file
df_cells_combined.to_csv(os.path.join(output_dir, 'dapi_data.txt'), sep='\t', index=False)
    
# =============================================================================
# READ AND PLOT MATRICES
# =============================================================================

# Read the edges matrix from the file
cd31_edges_df = pd.read_csv('CD31EdgeMatrices/CombinedSkeletons.txt', sep='\t', header=None, names=['x1', 'y1', 'x2', 'y2', 'edge_id'])
lectin_edges_df = pd.read_csv('lectinEdgeMatrices/CombinedSkeletons.txt', sep='\t', header=None, names=['x1', 'y1', 'x2', 'y2', 'edge_id'])

# Read the tab-separated file
cells_df = pd.read_csv('EdgeMatrices/dapi_data.txt', sep='\t')

# Create the plot
plt.figure(figsize=(10, 10))
diameter = cells_df['d']
sizes = diameter * scaling_factor

# Plot the cells
plt.scatter(cells_df['x'], cells_df['y'], c='blue', marker='o', alpha=0.2, s=sizes, label='Cells')

# Plot each line segment from the edges matrix
for _, row in cd31_edges_df.iterrows():
    plt.plot([row['x1'], row['x2']], [row['y1'], row['y2']], color='green', alpha=0.7, linewidth=5, label='CD31')
# Plot each line segment from the edges matrix
for _, row in lectin_edges_df.iterrows():
    plt.plot([row['x1'], row['x2']], [row['y1'], row['y2']], color='red', linewidth=2, ls='-', label='Lectin')

# Set x and y limits to match the square dimensions
plt.xlim(0, image_height_um)
plt.ylim(0, image_height_um)  # Inverted y-axis, so 1024 is at the top

# Label the plot
plt.xlabel('x-axis (μm)')
plt.ylabel('y-axis (μm)')
# plt.title('Segmentation plot (red=lectin, green=CD31, blue=DAPI)')
plt.grid(True)
# plt.legend()

# Show plot
plt.show()

# =============================================================================
# MARK PERFUSED VESSELS 
# =============================================================================

# Calculate midpoints for each edge in both skeletons
cd31_midpoints = edge_midpoint(cd31_edges_df)
lectin_midpoints = edge_midpoint(lectin_edges_df)

# Build a KDTree for the midpoints of the cd31 edges
tree = KDTree(cd31_midpoints)
tolerance = 18  # define the tolerance (in µm)

# Query the KDTree for edges in lectin_edges_df
lectin_indices = tree.query_ball_point(lectin_midpoints, r=tolerance)

# Create a new column to mark overlapping edges
cd31_edges_df['overlap'] = False

# Mark the overlapping edges
for idx, potential_matches in enumerate(lectin_indices):
    edge2 = lectin_edges_df.iloc[idx]
    for match in potential_matches:
        edge1 = cd31_edges_df.iloc[match]
        if check_overlap(edge1, edge2, tolerance):
            cd31_edges_df.at[match, 'overlap'] = True

# Display overlapping edges
print(cd31_edges_df)

# Plot all edges in cd31_edges_df
plt.figure(figsize=(10, 10))
diameter = cells_df['d']
for _, edge in cd31_edges_df.iterrows():
    color = 'r' if edge['overlap'] else 'k'  # Red for overlapping edges, black for non-overlapping
    plt.plot([edge['x1'], edge['x2']], [edge['y1'], edge['y2']], color=color, linewidth=2)

# # Optionally, plot edges from lectin_edges_df for comparison
# for _, edge in lectin_edges_df.iterrows():
#     plt.plot([edge['x1'], edge['x2']], [edge['y1'], edge['y2']], 'b--', linewidth=1)  # Blue dashed for lectin edges

# Set x and y limits to match the square dimensions
plt.xlim(0, image_height_um)
plt.ylim(0, image_height_um)  # Inverted y-axis, so 1024 is at the top

# Label the plot
plt.xlabel('x-axis (μm)')
plt.ylabel('y-axis (μm)')
# plt.title('Perfusion plot (red=perfused, black=hypoperfused)')
plt.grid(True)
# plt.legend()

# Show plot
plt.show()

# Count the number of overlapping edges
num_overlapping_edges = cd31_edges_df['overlap'].sum()

# Count the total number of edges in the first matrix
total_edges = len(cd31_edges_df)

# Calculate the PPV aka PF aka PQ
proportion_overlapping = num_overlapping_edges / total_edges
print(f"PF: {proportion_overlapping:.4f}")

# Save the updated CD31 edges dataframe with perfusion information to a text file
output_filename = os.path.join('perfusion.txt')

# Add a column for perfusion status (1 for perfused, 0 for hypoperfused)
cd31_edges_df['perfusion_status'] = cd31_edges_df['overlap'].astype(int)

# Save the dataframe to a .txt file, tab-separated
cd31_edges_df[['x1', 'y1', 'x2', 'y2', 'edge_id', 'perfusion_status']].to_csv(output_filename, sep='\t', index=False, header=False)

print(f"Perfusion data saved to {output_filename}")

# Calculate the lengths of all edges in the CD31 dataframe
cd31_edges_df['length'] = np.sqrt(
    (cd31_edges_df['x2'] - cd31_edges_df['x1'])**2 +
    (cd31_edges_df['y2'] - cd31_edges_df['y1'])**2
)

# Filter for perfused edges (perfusion_status == 1)
perfused_vessel_lengths = cd31_edges_df[cd31_edges_df['perfusion_status'] == 1]['length'].tolist()

# Calculate the Functional Capillary Density (FCD)
fcd = sum(perfused_vessel_lengths) / (image_height_um**2)

# Print the results
print(f"Number of perfused vessels: {len(perfused_vessel_lengths)}")
print(f"FCD: {fcd:.5f}")